{"paragraphs":[{"text":"%md\n\n### Build an Eventually Perfect Failure Detector\n\nAn Eventually Perfect Failure Detector (EPFD), in Kompics terms,  is a component that **provides** the following port *(already imported in the notebook)*.\n\n    class EventuallyPerfectFailureDetector extends Port {\n     indication[Suspect];\n     indication[Restore];\n    }\n\nSimply put, your component should indicate to an epfd port the following messages:\n\n    case class Suspect(process: Address) extends KompicsEvent;\n    case class Restore(process: Address) extends KompicsEvent;\n\nAs you have already learnt from the course lectures, an EPFD, defined in a partially synchronous model, should satisfy the following properties:\n\n1. **Completeness**:  *Every process that crashes should be eventually suspected permanently by every correct process*\n2. **Eventual Strong Accuracy**: *No correct process should be eventually suspected by any other correct process*\n   \nTo complete this assignment you will have to fill in the missing functionality denoted by the commented sections below and pass the property checking test at the end of this notebook.\n**HINT**: The recommended algorithm to use in this assignment is *EPFD with Increasing Timeout and Sequence Numbers*,  which you can find at the second page of this [document](https://courses.edx.org/asset-v1:KTHx+ID2203.1x+2016T3+type@asset+block@epfd.pdf) in the respective lecture.\n\n**Things to Remember**:\n1. The *Network* and *Timer* components are already provided by the simulator. No need to implement them.\n2. Execute the imports defined below **before** compiling your component implementation.\n3. We recommend making use of the component state and internal messages defined below to complete the implementation logic.\n4. You can always print messages to the output log, from within handlers to see what happens during the simulation. e.g. `println(s\"Process $self suspects $someProcess\");`\n5. Do not forget to run the checker code block in the end and ensure that all properties are satisfied before exporting your submission.\n6. You can always restart the Kompics Interpreter to start fresh (Interpreter->KompicsInterpreter->Click Restart)\n\nGood luck! :)","dateUpdated":"2016-09-09T22:50:14+0000","config":{"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"editorMode":"ace/mode/markdown","editorHide":true,"colWidth":12},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1473460986719_-1809542139","id":"20160909-160459_701472878","result":{"code":"SUCCESS","type":"HTML","msg":"<h3>Build an Eventually Perfect Failure Detector</h3>\n<p>An Eventually Perfect Failure Detector (EPFD), in Kompics terms,  is a component that <strong>provides</strong> the following port <em>(already imported in the notebook)</em>.</p>\n<pre><code>class EventuallyPerfectFailureDetector extends Port {\n indication[Suspect];\n indication[Restore];\n}\n</code></pre>\n<p>Simply put, your component should indicate to an epfd port the following messages:</p>\n<pre><code>case class Suspect(process: Address) extends KompicsEvent;\ncase class Restore(process: Address) extends KompicsEvent;\n</code></pre>\n<p>As you have already learnt from the course lectures, an EPFD, defined in a partially synchronous model, should satisfy the following properties:</p>\n<ol>\n<li><strong>Completeness</strong>:  <em>Every process that crashes should be eventually suspected permanently by every correct process</em></li>\n<li><strong>Eventual Strong Accuracy</strong>: <em>No correct process should be eventually suspected by any other correct process</em></li>\n</ol>\n<p>To complete this assignment you will have to fill in the missing functionality denoted by the commented sections below and pass the property checking test at the end of this notebook.\n<br  /><strong>HINT</strong>: The recommended algorithm to use in this assignment is <em>EPFD with Increasing Timeout and Sequence Numbers</em>,  which you can find at the second page of this <a href=\"https://courses.edx.org/asset-v1:KTHx+ID2203.1x+2016T3+type@asset+block@epfd.pdf\">document</a> in the respective lecture.</p>\n<p><strong>Things to Remember</strong>:</p>\n<ol>\n<li>The <em>Network</em> and <em>Timer</em> components are already provided by the simulator. No need to implement them.</li>\n<li>Execute the imports defined below <strong>before</strong> compiling your component implementation.</li>\n<li>We recommend making use of the component state and internal messages defined below to complete the implementation logic.</li>\n<li>You can always print messages to the output log, from within handlers to see what happens during the simulation. e.g. <code>println(s\"Process $self suspects $someProcess\");</code></li>\n<li>Do not forget to run the checker code block in the end and ensure that all properties are satisfied before exporting your submission.</li>\n<li>You can always restart the Kompics Interpreter to start fresh (Interpreter->KompicsInterpreter->Click Restart)</li>\n</ol>\n<p>Good luck! :)</p>\n"},"dateCreated":"2016-09-09T22:43:06+0000","dateStarted":"2016-09-09T22:50:14+0000","dateFinished":"2016-09-09T22:50:14+0000","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:4890","focus":true},{"text":"import se.kth.edx.id2203.core.Ports._\nimport se.kth.edx.id2203.validation._\nimport se.sics.kompics.network._\nimport se.sics.kompics.sl.{Init, _}\nimport se.sics.kompics.timer.{ScheduleTimeout, Timeout, Timer}\nimport se.sics.kompics.{KompicsEvent, Start, ComponentDefinition => _, Port => _}","dateUpdated":"2016-09-09T22:49:54+0000","config":{"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"editorMode":"ace/mode/scala","editorHide":false,"colWidth":12},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1473460986720_-1823777848","id":"20160623-152816_923395673","dateCreated":"2016-09-09T22:43:06+0000","dateStarted":"2016-09-09T22:49:54+0000","dateFinished":"2016-09-09T22:49:54+0000","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:4891"},{"text":"  //Custom messages to be used in the internal component implementation\n  case class CheckTimeout(timeout: ScheduleTimeout) extends Timeout(timeout);\n\n  case class HeartbeatReply(seq: Int) extends KompicsEvent;\n  case class HeartbeatRequest(seq: Int) extends KompicsEvent;","dateUpdated":"2016-09-09T22:49:54+0000","config":{"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"editorMode":"ace/mode/scala","colWidth":12},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1473460986720_-1823777848","id":"20160830-153841_517626554","dateCreated":"2016-09-09T22:43:06+0000","dateStarted":"2016-09-09T22:49:54+0000","dateFinished":"2016-09-09T22:49:55+0000","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:4892"},{"text":"\n//Define EPFD Implementation\nclass EPFD(epfdInit: Init[EPFD]) extends ComponentDefinition {\n\n  //EPFD subscriptions\n  val timer = requires[Timer];\n  val pLink = requires[PerfectLink];\n  val epfd = provides[EventuallyPerfectFailureDetector];\n\n  // EPDF component state and initialization\n  \n  //configuration parameters\n  val self = epfdInit match {case Init(s: Address) => s};\n  val topology = cfg.getValue[List[Address]](\"epfd.simulation.topology\");\n  val delta = cfg.getValue[Long](\"epfd.simulation.delay\");\n  \n  //mutable state\n  var period = cfg.getValue[Long](\"epfd.simulation.delay\");\n  var alive = Set(cfg.getValue[List[Address]](\"epfd.simulation.topology\"): _*);\n  var suspected = Set[Address]();\n  var seqnum = 0;\n\n  def startTimer(delay: Long): Unit = {\n    val scheduledTimeout = new ScheduleTimeout(period);\n    scheduledTimeout.setTimeoutEvent(CheckTimeout(scheduledTimeout));\n    trigger(scheduledTimeout -> timer);\n  }\n\n  //EPFD event handlers\n  ctrl uponEvent {\n    case _: Start => handle {\n        \n     /* WRITE YOUR CODE HERE  */\n     \n    }\n  }\n\n  timer uponEvent {\n    case CheckTimeout(_) => handle {\n      if (!alive.intersect(suspected).isEmpty) {\n          \n        /* WRITE YOUR CODE HERE  */\n        \n      }\n      \n      seqnum = seqnum + 1;\n      \n      for (p <- topology) {\n        if (!alive.contains(p) && !suspected.contains(p)) {\n            \n           /* WRITE YOUR CODE HERE  */\n           \n        } else if (alive.contains(p) && suspected.contains(p)) {\n          suspected = suspected - p;\n          trigger(Restore(p) -> epfd);\n        }\n        trigger(PL_Send(p, HeartbeatRequest(seqnum)) -> pLink);\n      }\n      alive = Set[Address]();\n      startTimer(period);\n    }\n  }\n\n  pLink uponEvent {\n    case PL_Deliver(src, HeartbeatRequest(seq)) => handle {\n        \n      /* WRITE YOUR CODE HERE  */  \n      \n    }\n    case PL_Deliver(src, HeartbeatReply(seq)) => handle {\n        \n      /* WRITE YOUR CODE HERE  */\n      \n    }\n  }\n};","dateUpdated":"2016-09-09T22:49:54+0000","config":{"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"editorMode":"ace/mode/scala","colWidth":12},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1473460986720_-1823777848","id":"20160728-151056_2139297732","dateCreated":"2016-09-09T22:43:06+0000","dateStarted":"2016-09-09T22:49:54+0000","dateFinished":"2016-09-09T22:49:55+0000","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:4893"},{"text":"checkEPFD[EPFD]","dateUpdated":"2016-09-09T22:49:54+0000","config":{"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"editorMode":"ace/mode/scala","colWidth":12},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1473460986720_-1823777848","id":"20160704-003955_2062490082","dateCreated":"2016-09-09T22:43:06+0000","dateStarted":"2016-09-09T22:49:55+0000","dateFinished":"2016-09-09T22:49:58+0000","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:4894"},{"text":"","dateUpdated":"2016-09-09T22:49:54+0000","config":{"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"editorMode":"ace/mode/scala","colWidth":12},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1473460986720_-1823777848","id":"20160728-143652_1894660652","dateCreated":"2016-09-09T22:43:06+0000","dateStarted":"2016-09-09T22:49:56+0000","dateFinished":"2016-09-09T22:49:58+0000","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:4895"}],"name":"Exercise: EPFD","id":"2BVDN7YVM","angularObjects":{"2BKQCVH92:shared_process":[],"2BMXUXUJ6:shared_process":[]},"config":{"looknfeel":"default"},"info":{}}