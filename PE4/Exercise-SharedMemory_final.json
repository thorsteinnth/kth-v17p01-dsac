{"paragraphs":[{"text":"%md\n\n### Implementing an Atomic N-N register \n\nIn this programming assignment you will have to complete the implementation of an atomic register that supports multiple writers and readers.\n\nWhen you are done you simply have to export your notebook and then upload it in the \"Programming Exercise 3\" page.\n\n**Things to Remember**:\n1. Basic components such as `PerfectLink`,  `Network` and `Timer` are already provided. No need to implement them.\n2. Execute the imports defined below **before** compiling your component implementations.\n3. We recommend making use of the component state and internal messages we have provided, if any, to complete the implementation logic.\n4. You can always print messages to the output log, from within handlers to see what happens during the simulation. e.g. `println(s\"Process $self delivers message $msg\");`\n5. Remember that during the simulation check you can print and observe the simulation time, i.e. with `System.currentTimeMillis()`.\n5. Do not forget to run the checker code block after each component implementation to ensure that all properties are satisfied **before** exporting and submitting the notebook.\n6. You can always restart the Kompics Interpreter to start fresh (Interpreter→KompicsInterpreter→Click Restart)\n\nGood luck! :)","dateUpdated":"2017-02-24T11:45:25+0000","config":{"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"editorMode":"ace/mode/scala","editorHide":true,"colWidth":12},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1487857594123_-2015847168","id":"20160920-133253_275876456","result":{"code":"SUCCESS","type":"HTML","msg":"<h3>Implementing an Atomic N-N register</h3>\n<p>In this programming assignment you will have to complete the implementation of an atomic register that supports multiple writers and readers.</p>\n<p>When you are done you simply have to export your notebook and then upload it in the &ldquo;Programming Exercise 3&rdquo; page.</p>\n<p><strong>Things to Remember</strong>:</p>\n<ol>\n<li>Basic components such as <code>PerfectLink</code>,  <code>Network</code> and <code>Timer</code> are already provided. No need to implement them.</li>\n<li>Execute the imports defined below <strong>before</strong> compiling your component implementations.</li>\n<li>We recommend making use of the component state and internal messages we have provided, if any, to complete the implementation logic.</li>\n<li>You can always print messages to the output log, from within handlers to see what happens during the simulation. e.g. <code>println(s\"Process $self delivers message $msg\");</code></li>\n<li>Remember that during the simulation check you can print and observe the simulation time, i.e. with <code>System.currentTimeMillis()</code>.</li>\n<li>Do not forget to run the checker code block after each component implementation to ensure that all properties are satisfied <strong>before</strong> exporting and submitting the notebook.</li>\n<li>You can always restart the Kompics Interpreter to start fresh (Interpreter→KompicsInterpreter→Click Restart)</li>\n</ol>\n<p>Good luck! :)</p>\n"},"dateCreated":"2017-02-23T13:46:34+0000","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:833","dateFinished":"2017-02-24T11:45:26+0000","dateStarted":"2017-02-24T11:45:25+0000"},{"text":"//Rremember to execute the following imports first\nimport se.kth.edx.id2203.core.ExercisePrimitives._\nimport se.kth.edx.id2203.core.Ports._\nimport se.kth.edx.id2203.validation._\nimport se.sics.kompics.network._\nimport se.sics.kompics.sl.{Init, _}\nimport se.sics.kompics.{ComponentDefinition => _, Port => _,KompicsEvent}\n\nimport scala.collection.mutable.Map\nimport scala.language.implicitConversions","dateUpdated":"2017-02-24T11:45:25+0000","config":{"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"editorMode":"ace/mode/scala","editorHide":false,"colWidth":12},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1487857594123_-2015847168","id":"20160830-120308_471915891","result":{"code":"SUCCESS","type":"HTML","msg":"import se.kth.edx.id2203.core.ExercisePrimitives._<br />import se.kth.edx.id2203.core.Ports._<br />import se.kth.edx.id2203.validation._<br />import se.sics.kompics.network._<br />import se.sics.kompics.sl.{Init, _}<br />import se.sics.kompics.{ComponentDefinition=>_, Port=>_, KompicsEvent}<br />import scala.collection.mutable.Map<br />import scala.language.implicitConversions<br />"},"dateCreated":"2017-02-23T13:46:34+0000","dateStarted":"2017-02-24T11:45:25+0000","dateFinished":"2017-02-24T11:45:25+0000","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:834","focus":true},{"text":"%md\n\n### Mini Scala-Refresher : The Scala Option ###\n\nIn this assignment you will have to work with Option types, so let's recap how they work. An `Option[T]` is a container for a value of type `T` which is **optional**. \nThat means that in case the value has been set, then `Option[T]` is actually an instance of `Some[T]`, which in turn contains the actual value of type `T`. \nIn case its value has not been set then the `Option[A]` is the object `None`.\n\nThus, it is good to have in mind the following e.g. for any  `value: Option[Any]`:\n\n\n1.When you want to initialize your optional value do it as such: \n```scala \nvalue = Some(myInitialValue) \n//or\nvalue = None;\n```\n2.In case you need to provide a default value in case of a `None` when you want to access an optional type you can do so like this:\n```scala\nval myVal:T = value.getOrElse(myDefaultValue)\n```\nOtherwise you can always simply get its value when you are sure it is not `None` like this:\n```scala\nif(value.isDefined){\n    myVal = value.get\n}\n```\n3.Beware of the following assignment: for `val myVal :Option[Any] = Some(1334)` then `val myOtherVal : Option[Any] = Some(myVal)` will not be `Some(1334)` but `Some(Some(1334))`","dateUpdated":"2017-02-24T11:45:25+0000","config":{"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"editorMode":"ace/mode/scala","editorHide":true,"colWidth":12},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1487857594123_-2015847168","id":"20160920-163834_1484371572","result":{"code":"SUCCESS","type":"HTML","msg":"<h3>Mini Scala-Refresher : The Scala Option</h3>\n<p>In this assignment you will have to work with Option types, so let's recap how they work. An <code>Option[T]</code> is a container for a value of type <code>T</code> which is <strong>optional</strong>.\n<br  />That means that in case the value has been set, then <code>Option[T]</code> is actually an instance of <code>Some[T]</code>, which in turn contains the actual value of type <code>T</code>.\n<br  />In case its value has not been set then the <code>Option[A]</code> is the object <code>None</code>.</p>\n<p>Thus, it is good to have in mind the following e.g. for any  <code>value: Option[Any]</code>:</p>\n<p>1.When you want to initialize your optional value do it as such:</p>\n<pre><code class=\"scala\">value = Some(myInitialValue) \n//or\nvalue = None;\n</code></pre>\n<p>2.In case you need to provide a default value in case of a <code>None</code> when you want to access an optional type you can do so like this:</p>\n<pre><code class=\"scala\">val myVal:T = value.getOrElse(myDefaultValue)\n</code></pre>\n<p>Otherwise you can always simply get its value when you are sure it is not <code>None</code> like this:</p>\n<pre><code class=\"scala\">if(value.isDefined){\n    myVal = value.get\n}\n</code></pre>\n<p>3.Beware of the following assignment: for <code>val myVal :Option[Any] = Some(1334)</code> then <code>val myOtherVal : Option[Any] = Some(myVal)</code> will not be <code>Some(1334)</code> but <code>Some(Some(1334))</code></p>\n"},"dateCreated":"2017-02-23T13:46:34+0000","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:835","dateFinished":"2017-02-24T11:45:26+0000","dateStarted":"2017-02-24T11:45:26+0000"},{"text":"%md\n\n## The N-N Atomic Register ##\n\nA (single) Atomic Register Abstraction (AR), in Kompics terms,  is a component that **provides** the following port *(already imported in the notebook)*.\n\n     class AtomicRegister extends Port {\n       request[AR_Read_Request]\n       request[AR_Write_Request]\n       indication[AR_Read_Response]\n       indication[AR_Write_Response]\n     }\n\n\nAn **AR** component should request reads (`AR_Read_Request`) or writes (`AR_Write_Request`) and respond with `AR_Read_Response` or `AR_Write_Response` events respectively as defined below:\n\n     case class AR_Read_Request() extends KompicsEvent\n     case class AR_Read_Response(value: Option[Any]) extends KompicsEvent\n     case class AR_Write_Request(value: Any) extends KompicsEvent\n     case class AR_Write_Response() extends KompicsEvent\n\n\nAs you have already learnt from the course lectures, Atomic Registers should be linerarizable and also terminate which we summarize with the following properties:\n\n1. **Termination**: *If a correct process invokes an operation, then the operation eventually completes.*\n2. **Atomicity**: *Every read operation returns the value that was written most recently in a hypothetical execution, where every failed operation appears to be complete or does not appear to have been invoked at all, and every complete operation appears to have been executed at some instant between its invocation and its completion.*\n\n\nHINT: The recommended algorithm to use in this assignment is *Read-Impose Write-Consult Majority* and is described at page 3 within the following  [document](https://d37djvu3ytnwxt.cloudfront.net/assets/courseware/v1/1c5fbe3090dfe445c8858e42c5925d0f/asset-v1:KTHx+ID2203.1x+2016T3+type@asset+block/atomicregister.pdf) in the respective lecture.\n","dateUpdated":"2017-02-24T11:45:25+0000","config":{"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"editorMode":"ace/mode/markdown","editorHide":true,"colWidth":12},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1487857594124_-2017770913","id":"20160920-163704_1475979424","result":{"code":"SUCCESS","type":"HTML","msg":"<h2>The N-N Atomic Register</h2>\n<p>A (single) Atomic Register Abstraction (AR), in Kompics terms,  is a component that <strong>provides</strong> the following port <em>(already imported in the notebook)</em>.</p>\n<pre><code> class AtomicRegister extends Port {\n   request[AR_Read_Request]\n   request[AR_Write_Request]\n   indication[AR_Read_Response]\n   indication[AR_Write_Response]\n }\n</code></pre>\n<p>An <strong>AR</strong> component should request reads (<code>AR_Read_Request</code>) or writes (<code>AR_Write_Request</code>) and respond with <code>AR_Read_Response</code> or <code>AR_Write_Response</code> events respectively as defined below:</p>\n<pre><code> case class AR_Read_Request() extends KompicsEvent\n case class AR_Read_Response(value: Option[Any]) extends KompicsEvent\n case class AR_Write_Request(value: Any) extends KompicsEvent\n case class AR_Write_Response() extends KompicsEvent\n</code></pre>\n<p>As you have already learnt from the course lectures, Atomic Registers should be linerarizable and also terminate which we summarize with the following properties:</p>\n<ol>\n<li><strong>Termination</strong>: <em>If a correct process invokes an operation, then the operation eventually completes.</em></li>\n<li><strong>Atomicity</strong>: <em>Every read operation returns the value that was written most recently in a hypothetical execution, where every failed operation appears to be complete or does not appear to have been invoked at all, and every complete operation appears to have been executed at some instant between its invocation and its completion.</em></li>\n</ol>\n<p>HINT: The recommended algorithm to use in this assignment is <em>Read-Impose Write-Consult Majority</em> and is described at page 3 within the following  <a href=\"https://d37djvu3ytnwxt.cloudfront.net/assets/courseware/v1/1c5fbe3090dfe445c8858e42c5925d0f/asset-v1:KTHx+ID2203.1x+2016T3+type@asset+block/atomicregister.pdf\">document</a> in the respective lecture.</p>\n"},"dateCreated":"2017-02-23T13:46:34+0000","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:836","dateFinished":"2017-02-24T11:45:26+0000","dateStarted":"2017-02-24T11:45:26+0000"},{"text":"\n  //The following events are to be used internally by the Atomic Register implementation below\n  case class READ(rid: Int) extends KompicsEvent;\n  case class VALUE(rid: Int, ts: Int, wr: Int, value: Option[Any]) extends KompicsEvent;\n  case class WRITE(rid: Int, ts: Int, wr: Int, writeVal: Option[Any]) extends KompicsEvent;\n  case class ACK(rid: Int) extends KompicsEvent;\n\n  /**\n    * This augments tuples with comparison operators implicitly, which you can use in your code. \n    * examples: (1,2) > (1,4) yields 'false' and  (5,4) <= (7,4) yields 'true' \n    */\n  implicit def addComparators[A](x: A)(implicit o: math.Ordering[A]): o.Ops = o.mkOrderingOps(x);\n\n//HINT: After you execute the latter implicit ordering you can compare tuples as such within your component implementation:\n(1,2) <= (1,4);\n","dateUpdated":"2017-02-24T11:45:25+0000","config":{"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"editorMode":"ace/mode/scala","colWidth":12},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1487857594124_-2017770913","id":"20160920-164336_1137661827","dateCreated":"2017-02-23T13:46:34+0000","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:837","dateFinished":"2017-02-24T11:45:25+0000","dateStarted":"2017-02-24T11:45:25+0000","result":{"code":"SUCCESS","type":"HTML","msg":"defined class READ<br />defined class VALUE<br />defined class WRITE<br />defined class ACK<br />addComparators: [A](x: A)(implicit o: scala.math.Ordering[A])o.Ops<br />res17: Boolean = true<br />"},"focus":true},{"text":"\nclass ReadImposeWriteConsultMajority(init: Init[ReadImposeWriteConsultMajority]) extends ComponentDefinition {\n\n  //subscriptions\n\n  val nnar = provides[AtomicRegister];\n\n  val pLink = requires[PerfectLink];\n  val beb = requires[BestEffortBroadcast];\n\n  //state and initialization\n\n  val (self: Address, n: Int, selfRank: Int) = init match {\n    case Init(selfAddr: Address, n: Int) => (selfAddr, n, AddressUtils.toRank(selfAddr))\n  };\n\n  var (ts, wr) = (0, 0);    // (timestamp, rank/pid)\n  var value: Option[Any] = None;\n  var acks = 0;\n  var readval: Option[Any] = None;\n  var writeval: Option[Any] = None;\n  var rid = 0;\n  var readlist: Map[Address, (Int, Int, Option[Any])] = Map.empty\n  var reading = false;\n\n  //handlers\n\n  nnar uponEvent {\n    case AR_Read_Request() => handle {\n      rid = rid + 1;\n      \n        /* MY CODE HERE  */\n        // Got read request (from client)\n        // Broadcast read request to all (start query phase)\n        acks = 0;\n        readlist.clear;\n        reading = true;\n        trigger(BEB_Broadcast(READ(rid)) -> beb); // Query request\n        \n        println(s\"$self - GOT READ REQUEST FROM CLIENT - BROADCASTED READ($rid) (QUERY REQUEST)\");\n        \n    };\n    case AR_Write_Request(wval) => handle { \n      rid = rid + 1;\n         \n        /* MY CODE HERE  */\n        // Got a write request (from client)\n        // Before writing, read from majority to get latest ts\n        // (query phase to get the latest ts before the update phase)\n        writeval = Some(wval);\n        acks = 0;\n        readlist.clear;\n        trigger(BEB_Broadcast(READ(rid)) -> beb);   // Query request\n     \n        println(s\"$self - GOT WRITE REQUEST FOR $wval FROM CLIENT - BROADCASTED READ($rid) (QUERY REQUEST)\");\n    }\n  }\n\n  beb uponEvent {\n    case BEB_Deliver(src, READ(readID)) => handle {\n        \n     /* MY CODE HERE  */\n     // Got read request (query request)\n     // Respond with local value v and ts (ts is a combo of timestamp and rank/pid)\n     trigger(PL_Send(src, VALUE(readID, ts, wr, value)) -> pLink);\n     \n     println(s\"$self - GOT QUERY REQUEST READ($readID) FROM $src - Responded with VALUE($readID, $ts, $wr, $value)\");\n     \n    }\n    case BEB_Deliver(src, w: WRITE) => handle {\n       \n     /* MY CODE HERE */\n     // I am in the update phase, got an update request\n     // P_j updates r = max(r, ((ts, pid), v)) and responds with ACK\n     if ((w.ts, w.wr) > (ts,wr))\n     {\n         // This new value is newer than my value.\n         // Let's update my value.\n         \n         ts = w.ts;\n         wr = w.wr;\n         value = w.writeVal;\n     }\n     \n     trigger(PL_Send(src, ACK(w.rid)) -> pLink);\n     \n     println(s\"$self - GOT $w FROM $src - Responded with ACK($w)\");\n     \n    }\n  }\n\n  pLink uponEvent {\n    case PL_Deliver(src, v: VALUE) => handle {\n      if (v.rid == rid) {\n         \n      /* MY CODE HERE  */\n      // I am waiting for responses from the read request I broadcasted (query request - query phase)\n      // Will save those responses, until I have a response from the majority of nodes in the system\n      readlist(src) = (v.ts, v.wr, v.value);\n      if (readlist.size > n/2)\n      {\n          // I have a read-request response from a majority of nodes (query phase responses)\n          // i.e. query phase is ending. Pick max(ts, pid) from the responses I got, and find the corresponding value\n          // PIDs used as tiebreakers.\n          \n          // Make a copy of the readlist combining the two Ints into one tuple so we can use that in maxBy\n          var readlist2: Map[Address, ((Int, Int), Option[Any])] = Map.empty\n          readlist foreach (x => readlist2(x._1) = ((x._2._1, x._2._2), x._2._3));\n          \n          var maxreadlist2: ((Int, Int), Option[Any]) = ((0, 0), None);\n          maxreadlist2 = (readlist2.maxBy(_._2._1))._2; // Should return max entry in readlist by timestamp and pid\n          var maxts = maxreadlist2._1._1;\n          var rr = maxreadlist2._1._2;\n          readval = maxreadlist2._2;\n\n          readlist.clear;\n          readlist2.clear;\n          \n          var bcastval: Option[Any] = None;\n          \n          if (reading)\n          {\n              // This is part of a read operation\n              // Perform an update phase with the highest (ts,v) where ts is a tuple of ts and pid\n              // Will broadcast the value v from the highest (ts,v) that I got from the other nodes,\n              // make all others WRITE that (i.e. update their value to that)\n              bcastval = readval;\n          }\n          else\n          {\n              // This is part of a write operation\n              // P_i starts an update phase by sending update request \n              // with register id r and timestamp-value pair ((ts+1, i), v)\n              // Make all others WRITE that (i.e. update their value to that)\n              \n              rr = selfRank;\n              maxts = maxts + 1;\n              bcastval = writeval;\n          }\n          \n          // NOTE: What is here rr is actually wr (rank/pid)\n          trigger(BEB_Broadcast(WRITE(rid, maxts, rr, bcastval)) -> beb);\n          \n          println(s\"$self - GOT $v FROM $src - READING $reading - BROADCAST WRITE ($rid, $maxts, $rr, $bcastval)\");\n      }\n      \n     \n      }\n    }\n    case PL_Deliver(src, v: ACK) => handle {\n      if (v.rid == rid) {\n  \n      /* MY CODE HERE  */\n      // P_i completes write (and read) when update phase ends\n      acks = acks + 1;\n      if (acks > n/2)\n      {\n          // Have got ACKs from a majority. Update phase ending.\n          acks = 0;\n          if (reading)\n          {\n              reading = false;\n              trigger(AR_Read_Response(readval) -> nnar);\n              println(s\"$self - GOT ENOUGH ACKS - READING - RETURNED $readval\");\n          }\n          else\n          {\n              trigger(AR_Write_Response() -> nnar);\n              println(s\"$self - GOT ENOUGH ACKS - WRITING\");\n          }\n      }\n      \n      }\n    }\n  }\n}","dateUpdated":"2017-02-24T14:30:06+0000","config":{"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"editorMode":"ace/mode/scala","colWidth":12},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1487857594124_-2017770913","id":"20160830-120402_168996820","dateCreated":"2017-02-23T13:46:34+0000","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:838","dateFinished":"2017-02-24T14:30:06+0000","dateStarted":"2017-02-24T14:30:06+0000","result":{"code":"SUCCESS","type":"HTML","msg":"defined class ReadImposeWriteConsultMajority<br />"},"focus":true},{"text":" checkNNAR[ReadImposeWriteConsultMajority]();","dateUpdated":"2017-02-24T14:30:27+0000","config":{"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"editorMode":"ace/mode/scala","colWidth":12},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1487857594124_-2017770913","id":"20160830-120430_1188854740","dateCreated":"2017-02-23T13:46:34+0000","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:839","dateFinished":"2017-02-24T14:30:30+0000","dateStarted":"2017-02-24T14:30:27+0000","result":{"code":"SUCCESS","type":"HTML","msg":"<br />Your submission has been locally simulated and validated.<br /><br /><a href=\"\\static\\log.txt\" target=\"_blank\">Click Here</a> to view the output of the simulation.<br /><style type=\"text/css\">.tg  {border-collapse:collapse;border-spacing:0;border-color:#aabcfe;}.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#aabcfe;color:#669;background-color:#e8edff;}.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#aabcfe;color:#039;background-color:#b9c9fe;}.tg .tg-mb3i{background-color:#D2E4FC;text-align:right;vertical-align:top}.tg .tg-lqy6{text-align:right;vertical-align:top}.tg .tg-vlnx{background-color:#3071a9;color:#ffffff;text-align:center;vertical-align:top}.tg .tg-6k2t{background-color:#D2E4FC;vertical-align:top}.tg tg-6k2l{background-color:#ffb3b3;vertical-align:top}.tg .tg-yw4l{vertical-align:top}</style><table class=\"tg\">  <tr>    <th class=\"tg-vlnx\" colspan=\"3\">Correction Results</th>  </tr><br /><tr>    <td class=\"tg-6k2t\">PASSED</td> <td class=\"tg-6k2t\">Termination</td> <td class=\"tg-6k2t\">✔: Every operation invoked by a correct process eventually completes<br></td>  </tr>  <br /><tr>    <td class=\"tg-6k2t\">PASSED</td> <td class=\"tg-6k2t\">Atomicity/Linerizability</td> <td class=\"tg-6k2t\">✔: Every read operation returns the value that was written most recently in a hypothetical global execution<br></td>  </tr>  <br /></table><br />Final Comments<br />**************<br />Congratulations! Your implementation of the 'NN Atomic Register' satisfies all properties! <br />A unique token has been generated for your submission right below. Please do not edit. <br /><br />{\"gradingToken\":[45,45,45,45,45,66,69,71,73,78,32,80,71,80,32,77,69,83,83,65,71,69,45,45,45,45,45,10,86,101,114,115,105,111,110,58,32,66,67,80,71,32,118,49,46,53,53,10,10,104,81,73,77,65,57,79,116,77,118,84,69,98,74,49,102,65,81,47,43,77,112,106,66,50,68,109,111,79,57,66,51,122,100,77,114,88,103,82,102,78,99,78,80,80,100,116,68,51,90,51,118,57,72,118,73,119,87,98,112,68,111,72,83,10,106,115,71,56,47,112,52,119,106,115,108,73,76,88,53,53,71,116,66,106,49,85,67,73,80,85,118,86,77,88,89,66,101,110,82,111,107,83,107,107,113,76,108,104,78,65,66,69,103,102,99,68,69,111,72,106,52,99,105,80,65,122,75,103,10,82,73,72,73,99,70,102,108,55,65,77,105,115,71,77,107,85,102,121,102,73,89,50,117,51,72,55,49,107,66,113,74,56,77,76,84,78,79,74,80,85,75,65,67,84,119,99,73,49,100,49,121,101,105,100,83,115,75,76,73,108,115,55,68,10,97,116,108,87,118,70,87,108,114,109,74,105,89,115,70,43,111,90,56,101,99,54,78,99,80,78,81,121,80,48,73,101,89,49,85,54,68,87,85,67,48,122,99,54,75,56,108,102,88,86,89,115,86,53,86,68,119,114,80,69,105,73,114,101,10,87,82,49,49,121,105,120,57,97,121,101,119,112,121,88,90,49,119,52,116,99,54,53,106,86,98,57,73,74,78,116,48,106,110,75,113,106,112,54,103,85,82,116,76,85,67,66,106,84,53,110,86,109,80,115,117,121,89,49,66,112,80,51,57,10,103,54,54,119,122,57,89,88,111,75,110,48,122,119,73,67,82,80,101,67,109,104,75,88,104,116,50,52,100,118,82,82,122,76,80,104,85,43,98,76,101,68,78,65,66,117,72,73,117,48,117,73,97,121,112,79,65,70,75,105,108,74,78,86,10,90,86,66,70,73,69,111,112,112,70,67,122,104,86,85,53,75,109,87,73,73,103,122,70,78,74,115,110,88,48,109,55,76,76,87,106,83,111,56,103,68,76,76,70,82,110,78,47,84,97,114,75,51,117,57,89,87,99,48,103,107,84,105,66,10,122,52,112,65,111,83,84,115,108,43,120,82,70,122,52,114,120,107,102,70,112,113,54,73,67,114,119,79,56,101,98,87,98,74,76,65,54,104,106,100,117,101,47,117,117,78,85,43,82,120,111,69,87,80,105,90,112,104,119,68,87,81,118,113,10,70,84,108,50,110,122,72,100,71,103,110,102,111,79,68,84,102,48,102,55,84,69,75,52,82,66,121,109,97,55,68,76,112,85,83,43,75,73,112,82,86,108,100,50,106,87,109,111,78,57,48,117,87,74,110,89,110,107,122,107,102,109,80,105,10,55,82,113,66,48,47,106,83,111,69,122,66,85,43,70,87,75,90,75,114,107,79,112,85,77,115,69,114,122,43,121,76,113,48,109,88,79,116,109,122,75,80,105,117,101,86,113,90,98,104,86,88,104,47,43,80,69,50,109,98,121,68,110,83,10,121,82,71,53,72,86,52,122,77,113,57,99,110,108,114,65,77,75,85,47,100,65,78,87,76,88,69,113,65,105,66,102,103,48,66,68,78,86,53,69,105,74,81,65,43,67,82,82,72,48,108,121,67,76,87,82,84,121,119,71,50,57,98,83,10,119,65,115,66,122,105,108,82,117,52,103,51,104,66,117,121,78,112,80,86,53,47,87,107,79,83,80,103,49,88,113,90,47,81,48,90,122,101,78,118,74,83,67,88,65,81,72,117,57,112,69,103,120,52,90,108,43,66,69,67,90,111,65,106,10,102,121,71,78,54,80,117,47,65,105,71,78,86,72,104,53,99,100,55,47,86,85,43,113,100,110,90,51,47,51,89,57,49,112,102,65,87,121,77,76,54,82,78,72,49,112,122,73,89,82,116,52,51,122,68,70,52,97,74,83,65,68,111,80,10,54,72,101,48,102,121,103,85,107,117,87,88,118,104,122,76,57,68,56,122,55,108,75,109,107,111,113,72,51,88,105,104,50,97,116,116,122,69,71,107,43,77,87,79,49,53,118,67,48,74,50,117,86,65,98,79,56,117,77,84,77,47,100,57,10,68,67,80,110,53,104,73,120,112,48,114,108,68,82,111,54,67,107,75,47,76,104,117,53,72,98,116,70,105,106,73,78,109,54,76,82,101,51,102,71,49,83,79,86,73,68,114,110,102,68,84,70,104,47,50,99,78,118,71,111,57,54,55,76,10,48,103,103,77,76,111,100,120,118,66,120,111,99,70,103,73,84,65,61,61,10,61,78,89,105,97,10,45,45,45,45,45,69,78,68,32,80,71,80,32,77,69,83,83,65,71,69,45,45,45,45,45,10]}<br />"},"focus":true},{"dateUpdated":"2017-02-24T11:45:25+0000","config":{"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"editorMode":"ace/mode/scala","colWidth":12},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1487857594124_-2017770913","id":"20160830-120658_2133406867","dateCreated":"2017-02-23T13:46:34+0000","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:840","dateFinished":"2017-02-24T11:45:28+0000","dateStarted":"2017-02-24T11:45:26+0000","result":{"code":"SUCCESS","type":"TEXT","msg":""}}],"name":"Exercise-SharedMemory","id":"2CBU6VKGC","angularObjects":{"2BKQCVH92:shared_process":[],"2BMXUXUJ6:shared_process":[]},"config":{"looknfeel":"default"},"info":{}}